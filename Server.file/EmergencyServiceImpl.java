package com.smartcity.server;

import com.smartcity.emergency.*;
import io.grpc.stub.StreamObserver;

import java.util.ArrayList;
import java.util.List;

// This class implements the service defined in the .proto file.
// EmergencyServiceImplBase is an abstract class automatically generated by gRPC.
public class EmergencyServiceImpl extends EmergencyServiceGrpc.EmergencyServiceImplBase {

    /**
     * This method implements the Bidirectional Streaming RPC: reportAccident.
     * The client sends multiple AccidentReport messages.
     * The server responds with EmergencyUpdate messages while receiving.
     */
    
    @Override
    public StreamObserver<AccidentReport> reportAccident(StreamObserver<EmergencyUpdate> responseObserver) {
        return new StreamObserver<AccidentReport>() {
            private int counter = 1;
            
            // This method is called each time the server receives a new accident report
            @Override
            public void onNext(AccidentReport report) {
                String location = report.getLocation();     // Get location from client message
                String severity = report.getSeverity();     // Get severity from client message
                // Create a response message with report number and location
                String message = "Emergency response dispatched to: " + location + " #" + counter;
                counter++;   // Increase message counter
                // Print for debugging
                System.out.println(" Accident received - Location: " + location + ", Severity: " + severity);
                System.out.println( message);
                // Build and send the response to the client immediately
                EmergencyUpdate update = EmergencyUpdate.newBuilder()
                        .setUpdateMessage(message)
                        .build();

                responseObserver.onNext(update);  // Send response back to the client
            }   
            // If any error happens during the communication
            @Override
            public void onError(Throwable t) {
                System.err.println(" Error in Bidirectional reportAccident: " + t.getMessage());
            }
            // This method is called when the client is done sending data
            @Override
            public void onCompleted() {
                System.out.println(" Accident reporting stream completed.");
                responseObserver.onCompleted();
            }
        };
    }

     /**
     * This method implements the Server Streaming RPC: notifyEmergencyTeams.
     * The client sends one EmergencyRequest, and the server sends multiple responses.
     */
    @Override
    public void notifyEmergencyTeams(EmergencyRequest request, StreamObserver<EmergencyUpdate> responseObserver) {
        // Print team ID to the console for logging
         System.out.println("NotifyEmergencyTeams called with Team ID: " + request.getTeamId());

    for (int i = 1; i <= 3; i++) {
        // Simulate three stages of response messages
         String teamId = request.getTeamId();   // Get team ID from the request

    // Reply to three-stage messages
    String[] messages = {
            teamId + " received the notification.",
            teamId + " is ready to go.",
            teamId + " has arrived."
    };
    // Loop through each message and send to the client
    for (String msg : messages) {
        EmergencyUpdate update = EmergencyUpdate.newBuilder()
                .setUpdateMessage(msg)
                .build();
        responseObserver.onNext(update);    // Send each message

        try {
            Thread.sleep(500);      // Simulate delay (0.5 seconds) between messages
        } catch (InterruptedException e) {
            e.printStackTrace();    // Print if something goes wrong with sleep
        }
    }
    // After all messages sent, close the stream
    responseObserver.onCompleted();
    System.out.println(" notifyEmergencyTeams: Notification completed for " + teamId);
    }

    }
}
